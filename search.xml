<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C# 語法學習_Lesson 6]]></title>
    <url>%2F2019%2F11%2F19%2FCsharp%2FCsharp_Learning%2FLesson.6%2F</url>
    <content type="text"><![CDATA[C# 語法學習_Lesson 6欄位「欄位」 是與類別或類別執行個體關聯的變數。使用 static 修飾詞來宣告的欄位會定義靜態欄位。 靜態欄位只會識別一個儲存位置。 不論建立多少個類別執行個體，都只會有一個靜態欄位複本。未使用 static 修飾詞來宣告的欄位會定義執行個體欄位。 每個類別執行個體都包含一個該類別所有執行個體欄位的個別複本。 在下列範例中，每個 Color 類別執行個體都具有 r、g 及 b 執行個體欄位的個別複本，但只有一個 Black、White、Red、Green 及 Blue 靜態欄位的複本： 1234567891011121314151617public class Color&#123; public static readonly Color ; Black = new Color(0, 0, 0); public static readonly Color White = new Color(255, 255, 255); public static readonly Color Red = new Color(255, 0, 0); public static readonly Color Green = new Color(0, 255, 0); public static readonly Color Blue = new Color(0, 0, 255); private byte r, g, b; public Color(byte r, byte g, byte b) &#123; this.r = r; this.g = g; this.b = b; &#125;&#125; 如先前的範例所示，可以使用 readonly 修飾詞來宣告「唯讀欄位」 。 只有在欄位的宣告或在相同類別的建構函式中，才能對 readonly 欄位進行指派。 方法方法 是實作物件或類別所能執行之計算或動作的成員。 存取「靜態方法」時，是透過類別來存取。 存取「執行個體方法」 時，是透過類別的執行個體來存取。 方法可能會有一份「參數」 清單和「傳回型別」 ，前者代表傳送給方法的值或變數參考，後者則指定方法所計算並傳回的值型別。 如果方法不會傳回值，則其傳回型別為 void。 1234567891011public static string ddStr(string abc)&#123; string resultStr = ""; ... return resultStr;&#125;public void doSomething()&#123; ...&#125; 與型別相同，方法也可能有一組型別參數，而呼叫方法時，必須為這些參數指定型別引數。 與型別不同的是，型別引數通常可以從方法呼叫的引數推斷，而不需要明確指定。 在宣告方法的類別中，每一個方法的「簽章」 必須是唯一的。 方法的簽章是由方法的名稱、型別參數的數目以及其參數的數目、修飾詞和型別所組成。 方法的簽章並不包括傳回型別。 123456789public void doSomething()&#123; ...&#125;public string doSomething(string abc)&#123; return abc; &#125; 參數參數(Parameters)主要是用來傳遞值(value)或變數參考(variable references)給方法，方法中的參數會從叫用方法時(invoke)所指定的「引數」 取得其實際值。參數有四種：值參數(value parameters)參考參數(reference parameters)輸出參數(output parameters)參數陣列(parameter arrays) 值參數 適用於傳遞輸入的引數，此變數會從參數傳遞的引數取得其初始值並對應到區域變數，變更原本參數的值，並不會引響到已傳遞輸入引數的值 12345678910111213141516using System;class ValueExample&#123; public string doSomething(string abc) &#123; return abc; &#125; public static void ValueTest() &#123; string abc = "test123"; string result = doSomething(abc); abc = "2345866"; Console.WriteLine($"&#123;result&#125; &#123;abc&#125;") //Ouputs "test123 2345866" &#125;&#125; 參考參數 適用於以參考方式傳遞引數，參考參數傳遞的引數必須是含有定義值的變數，而且在方法執行的期間，參考參數和引數變數是使用相同的儲存位址。宣告參考參數時，是使用 ref 修飾詞來宣告 12345678910111213141516using System;class RefExample&#123; static void Swap(ref int x, ref int y) &#123; int temp = x; x = y; y = temp; &#125; public static void SwapExample() &#123; int i = 1, j = 2; Swap(ref i, ref j); Console.WriteLine($"&#123;i&#125; &#123;j&#125;"); // Outputs "2 1" &#125;&#125; 輸出參數 適用於以參考方式傳遞引數，類似於參考參數，只不過它並不需要明確指派值給呼叫端提供的引數。宣告輸出參數時，是使用 out 修飾詞來宣告。 1234567891011121314using System; class OutExample &#123; static void Divide(int x, int y, out int result, out int remainder) &#123; result = x / y; remainder = x % y; &#125; public static void OutUsage() &#123; Divide(10, 3, out int res, out int rem); Console.WriteLine("&#123;0&#125; &#123;1&#125;", res, rem); // Outputs "3 1" &#125; &#125; 參數陣列 可允許將數目不固定的引數傳遞給方法。宣告參數陣列時，是使用 params 修飾詞來宣告。 只有方法的最後一個參數可以是參數陣列，而參數陣列的型別必須是單一維度陣列型別。 123456public class Console&#123; public static void Write(string fmt, params object[] args) &#123; &#125; public static void WriteLine(string fmt, params object[] args) &#123; &#125; // ...&#125; 在使用參數陣列的方法內，參數陣列的行為與陣列型別的一般參數完全相同。 不過，在叫用含有參數陣列的方法時，可以傳遞單一的參數陣列型別引數，或是傳遞任意數目的參數陣列元素型別引數。 在後者的案例中，會自動建立陣列執行個體並以指定的引數將其初始化。 以下範例 12345678910//範例1Console.WriteLine("x=&#123;0&#125; y=&#123;1&#125; z=&#123;2&#125;", x, y, z);//範例2string s = "x=&#123;0&#125; y=&#123;1&#125; z=&#123;2&#125;";object[] args = new object[3];args[0] = x;args[1] = y;args[2] = z;Console.WriteLine(s, args);]]></content>
      <categories>
        <category>C# 語法學習</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 語法學習_Lesson 5]]></title>
    <url>%2F2019%2F11%2F19%2FCsharp%2FCsharp_Learning%2FLesson.5%2F</url>
    <content type="text"><![CDATA[C# 語法學習_Lesson 5類別與物件class(類別)是C#最基本的型別，類別是一個結合狀態(fields)和動作(methods &amp; function members)於一個單元的資料結構，類別可以為動態建立的類別「instance」 (稱為「object」 ) 提供定義。 class可以支援物件導向概念中的繼承(inheritance)和多型(polymorphism)，因為這樣的機制，所以base class(基底類別)是可以被擴展(衍生類別)或是特製化。 建立新類別時，是使用類別宣告來建立。類別宣告的開頭是一個標頭，此標頭會指定類別的屬性和修飾詞、類別的名稱、基底類別 (如果提供)，以及類別所實作的介面。此標頭後面會接著類別主體，此主體是由在 { 與 } 分隔符號之間撰寫的成員宣告清單所組成。 以下是一個名為 Point 之簡單類別的宣告： 123456789public class Point&#123; public int x, y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125; 建立類別執行個體(instance)時，是使用 new 運算子來建立，此運算子會為新執行個體配置記憶體、叫用建構函式來將執行個體初始化，然後傳回對執行個體的參考。 下列陳述式會建立兩個 Point 物件，並以兩個變數儲存對這些物件的參考： 12Point p1 = new Point(0, 0);Point p2 = new Point(10, 20); 當物件(object)已經無效時，其所佔用的記憶體空間，將會自動被釋放，在 C# 中，既沒有必要也不可能很明確地將解除物件配置的記憶體空間。 成員(members)類別的成員不是靜態成員，就是執行個體成員，靜態成員隸屬於類別，而執行個體成員則隸屬於物件 (類別的執行個體)。 以下提供類別所能包含之成員類型的概觀。常數(Constants)與類別關聯的常數值欄位(Fields)類別的變數方法(Methods)類別所能執行的計算和動作屬性(Properties)與讀取和寫入具名的類別特性關聯的動作索引子(Indexers)與編製陣列之類的類別執行個體關聯的動作事件(Events)類別所能產生的通知運算子(Operators)類別所支援的轉換和運算式運算子建構函式(Constructors)將類別執行個體或類別本身初始化所需的動作完成項(Finalizers)在永久捨棄類別執行個體之前所要執行的動作型別(Types)類別所宣告的巢狀型別 輔助項目類別中的每個成員都有一個關聯存取的能力，用來控制能夠存取成員的程式碼區塊，取能力有六種可能的形式。 以下為摘要說明。 public存取不受限制protected存取僅限於此類別或此類別所衍生的類別internal存取限於目前組件 (.exe、.dll 等)protected internal存取限於包含類別、衍生自包含類別的類別，或同組件中的類別private存取僅限於此類別private protected存取限於包含類別或衍生自同組件中包含類型的類別 型別參數類別定義可以在類別名稱後面以角括弧括住型別參數名稱清單，來定義一組型別參數。 接著，就可以在類別宣告的主體中使用這些型別參數，來定義類別的成員。 在下列範例中，Pair 的型別參數是 TFirst 和 TSecond： 12345public class Pair&lt;TFirst,TSecond&gt;&#123; public TFirst First; public TSecond Second;&#125; 類別型別若宣告為會採用型別參數，即稱為「泛型類別型別」 。 結構、介面及委派型別也可以是泛型型別。 使用泛型類別時，必須為每個型別參數提供型別參數： 123Pair&lt;int,string&gt; pair = new Pair&lt;int,string&gt; &#123; First = 1, Second = "two" &#125;;int i = pair.First; // TFirst is intstring s = pair.Second; // TSecond is string 基底類別類別宣告可以在類別名稱和型別參數後面加上冒號和基底類別的名稱，來指定基底類別。 省略基底類別規格即等同於衍生自類型 object。 在下列範例中，Point3D 的基底類別是 Point，而 Point 的基底類別是 object： 12345678910111213141516171819public class Point&#123; public int x, y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125;&#125;public class Point3D: Point&#123; public int z; public Point3D(int x, int y, int z) : base(x, y) &#123; this.z = z; &#125;&#125; 類別會繼承其基底類別的成員。 繼承意謂著類別隱含地包含其基底類別的所有成員，但不包含基底類別中的instance,靜態建構子及完成項。衍生類別可以在其繼承的成員中新增新的成員，但無法移除所繼承成員的定義。 在先前的範例中，Point3D 會從 Point 繼承 x 和 y 欄位，而每個 Point3D 執行個體都會包含 x、y 及 z 這三個欄位。 在類別型別和其任何基底類別型別之間都存在著隱含轉換。 因此，類別型別的變數可以參考該類別的執行個體，或任何衍生類別的執行個體。 例如，以先前的類別宣告為例，Point 型別的變數可以參考 Point 或 Point3D： 12Point a = new Point(10, 20);Point b = new Point3D(10, 20, 30);]]></content>
      <categories>
        <category>C# 語法學習</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 語法學習_Lesson 4]]></title>
    <url>%2F2019%2F11%2F18%2FCsharp%2FCsharp_Learning%2FLesson.4%2F</url>
    <content type="text"><![CDATA[C# 語法學習_Lesson 4陳述式程式的動作是藉由陳述式來表達。 C# 支援數種不同類型的陳述式，也包含一些內嵌陳述式。 「區塊」可允許單一陳述式或多個陳述式內容。 區塊是指在 { 與 } 分隔符號之間撰寫的陳述式所組成。 「宣告陳述式」可用來宣告區域變數和常數。 123456789101112static void Declarations(string[] args)&#123; //區域變數陳述式 int a; int b = 2, c = 3; a = 1; Console.WriteLine(a + b + c); //常數陳述式 const float pi = 3.1415927f; const int r = 25; Console.WriteLine(pi * r * r);&#125; 「運算式陳述式」可用來評估運算式。 可用來作為陳述式的運算式包括方法叫用、使用 new 運算子的物件配置、使用 = 和複合指派運算子的指派、使用 ++ 和 – 運算子的遞增和遞減運算，以及 await 運算。 12345678static void Expressions(string[] args)&#123; int i; i = 123; // Expression statement Console.WriteLine(i); // Expression statement i++; // Expression statement Console.WriteLine(i); // Expression statement&#125; 「選取陳述式」可用來根據某個運算式的值選取執行對應的陳述式。 在此群組中的是 if 和 switch 陳述式。 123456789101112131415161718192021222324252627static void IfStatement(string[] args)&#123; //if 陳述式 if (args.Length == 0) &#123; Console.WriteLine("No arguments"); &#125; else &#123; Console.WriteLine("One or more arguments"); &#125; //switch 陳述式 int n = args.Length; switch (n) &#123; case 0: Console.WriteLine("No arguments"); break; case 1: Console.WriteLine("One argument"); break; default: Console.WriteLine($"&#123;n&#125; arguments"); break; &#125;&#125; 「重覆運算陳述式」可用來重複執行內嵌的陳述式。 在此群組中的是 while、do、for 及 foreach 陳述式。 123456789101112131415161718192021222324252627282930static void WhileStatement(string[] args)&#123; //while 陳述式 int i = 0; while (i &lt; args.Length) &#123; Console.WriteLine(args[i]); i++; &#125; // do while 陳述式 string s; do &#123; s = Console.ReadLine(); Console.WriteLine(s); &#125; while (!string.IsNullOrEmpty(s)); // for 陳述式 for (int i = 0; i &lt; args.Length; i++) &#123; Console.WriteLine(args[i]); &#125; // foreach 陳述式 foreach (string s in args) &#123; Console.WriteLine(s); &#125;&#125; 「跳躍陳述式」可用來轉移控制項。 在此群組中的是 break、continue、goto、throw、return 及 yield 陳述式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static void BreakStatement(string[] args)&#123; // break while (true) &#123; string s = Console.ReadLine(); if (string.IsNullOrEmpty(s)) break; //跳出迴圈 Console.WriteLine(s); &#125; // continue for (int i = 0; i &lt; args.Length; i++) &#123; if (args[i].StartsWith("/")) continue; Console.WriteLine(args[i]); &#125; // goto int i = 0; goto check; loop: Console.WriteLine(args[i++]); check: if (i &lt; args.Length) goto loop; &#125;// returnstatic int Add(int a, int b) &#123; return a + b;&#125;static void ReturnStatement(string[] args)&#123; Console.WriteLine(Add(1, 2)); return;&#125;//yieldstatic System.Collections.Generic.IEnumerable&lt;int&gt; Range(int start, int end) &#123; for (int i = start; i &lt; end; i++) &#123; yield return i; &#125; yield break;&#125;static void YieldStatement(string[] args)&#123; foreach (int i in Range(-10,10)) &#123; Console.WriteLine(i); &#125;&#125; try…catch 陳述式可用來攔截在執行區塊時發生的例外狀況，而 try…finally 陳述式則可用來指定不論是否發生例外狀況都一律會執行的最終處理程式碼。 123456789101112131415161718192021222324252627static double Divide(double x, double y) &#123; if (y == 0) throw new DivideByZeroException(); return x / y;&#125;static void TryCatch(string[] args) &#123; try &#123; if (args.Length != 2) &#123; throw new InvalidOperationException("Two numbers required"); &#125; double x = double.Parse(args[0]); double y = double.Parse(args[1]); Console.WriteLine(Divide(x, y)); &#125; catch (InvalidOperationException e) &#123; Console.WriteLine(e.Message); &#125; finally &#123; Console.WriteLine("Good bye!"); &#125;&#125; checked 和 unchecked 陳述式可用來控制整數型別算術運算和轉換的溢位檢查內容。 123456789101112static void CheckedUnchecked(string[] args) &#123; int x = int.MaxValue; unchecked &#123; Console.WriteLine(x + 1); // Overflow &#125; checked &#123; Console.WriteLine(x + 1); // Exception &#125; &#125; lock 陳述式可用來取得所指定物件的互斥鎖定、執行陳述式，然後釋放鎖定。 1234567891011121314151617class Account&#123; decimal balance; private readonly object sync = new object(); public void Withdraw(decimal amount) &#123; lock (sync) &#123; if (amount &gt; balance) &#123; throw new Exception( "Insufficient funds"); &#125; balance -= amount; &#125; &#125;&#125; using 陳述式可用來取得資源、執行陳述式，然後處置該資源。以下列出可供使用的陳述式類型，並提供每個陳述式的範例。 123456789static void UsingStatement(string[] args) &#123; using (TextWriter w = File.CreateText("test.txt")) &#123; w.WriteLine("Line one"); w.WriteLine("Line two"); w.WriteLine("Line three"); &#125;&#125;]]></content>
      <categories>
        <category>C# 語法學習</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 語法學習_Lesson 3]]></title>
    <url>%2F2019%2F11%2F18%2FCsharp%2FCsharp_Learning%2FLesson.3%2F</url>
    <content type="text"><![CDATA[C# 語法學習_Lesson 3運算式「運算式」是由「運算元」和「運算子」建構而成。 運算式的運算子會指出要將哪些運算套用到運算元。 運算子範例包括 +、-、*、/ 及 new。 運算元範例包括常值、欄位、區域變數及運算式。 當運算式包含多個運算子時，運算子的「優先順序」會控制評估個別運算子的順序。 例如，運算式 x + y * z 會評估為 x + (y * z)，因為 * 運算子的優先順序高於 + 運算子。 當兩個優先順序相同的運算子之間有運算元時，運算子的「關聯性」會控制執行運算的順序：除了指派和 null 聯合運算子之外，所有二元運算子都是左關聯的，這表示作業是由左至右執行。 例如，x + y + z 會判斷值為 (x + y) + z。 指派運算子、null 表達式(?? 和 ??= 運算子)，而條件運算子 ?: 是靠右關聯的，這表示作業是由右至左執行。 例如，x = y = z 會判斷值為 x = (y = z)。 您可以使用括弧來控制優先順序和關聯性。 例如，x + y * z 會先將 y 乘以 z，然後再將結果加到 x，而 (x + y) * z 則會先將 x 與 y 相加，然後再將結果乘以 z。 大部分的運算子都可以「多載」。 運算子多載可允許針對一個運算元屬於 (或兩個運算元都屬於) 使用者定義之類別或結構型別的運算式，指定使用者定義的運算子實作。 C# 提供數個運算子，用於執行算術、邏輯、位元和移位作業以及相等和順序比較。]]></content>
      <categories>
        <category>C# 語法學習</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 語法學習_Lesson 2]]></title>
    <url>%2F2019%2F11%2F15%2FCsharp%2FCsharp_Learning%2FLesson.2%2F</url>
    <content type="text"><![CDATA[C# 語法學習_Lesson 2型別與變數C# 有兩種型別(Types): 實質型別(value type)及參考型別(reference type)實質型別(value type)的變數本身就包含代入的資料。參考型別(reference type)的變數僅是代入一個資料的參考連結，這個資料通常為一個物件(object)在參考型別中，可允許兩個以上的變數參考同一個物件(object)，因此對其中一個變數進行的操作可能會影響另一個變數所參考的物件。而使用實質型別時，變數各自有自己的資料複本，因此在某一個變數上進行的操作，不會影響到其它的變數(ref及 out參數變數除外) 實值型別 簡單型別 1234561. 帶正負號的整數︰sbyte、short、int、long2. 不帶正負號的整數︰byte、ushort、uint、ulong3. Unicode 字元：char4. IEEE 二進位浮點：float、double5. 高精確度十進位浮點：decimal6. 布林值：bool 列舉型別 1使用者定義型別，格式為 enum E &#123;...&#125; 結構型別 1使用者定義型別，格式為 struct S &#123;...&#125; 可為Null的實值型別 1含有 null 值的所有其他數值型別的擴充 參考型別 類別型別 1231. 所有其他型別的基底類別︰object2. Unicode 字串：string3. 使用者定義型別，格式為 class C &#123;...&#125; 介面型別 1使用者定義型別，格式為 interface I &#123;...&#125; 陣列型別 1單一維度和多維度，例如 int[] 和 int[,] 委派型別 1使用者定義型別，格式為 delegate int D(...) bool type(布林型別)的值為 true 或 false。 Character 和 string 在C#中是使用Unicode編碼，所以 char 型別為一個UTF-16編碼字元單位，而 string型別則為一串UTF-16編碼字元集。 C#的程式是使用型別宣告來建立新的class。 型別宣告會指定新型別的名稱(name)和成員(members)。可由使用者定義的五種 C# 型別類型︰類別型別(class types)、結構型別(struct types)、介面型別(interface types)、列舉型別(enum types)及委派型別(delegate types)。 class 型別是定義一個資料結構，其中包含資料成員 (fields) 和函式成員 (method、properties及others)。 類別型別支援單一繼承和多型，因為這樣的機制，class是可以擴展沿伸(extend)及特製化。 struct 型別與class型別相似，它一樣具有資料成員和函式成員的結構。 不過，不同於類別，結構是實值型別，而且通常不需要堆積配置。 結構型別不支援使用者指定的繼承，且所有結構型別都隱含地繼承自 object 型別。 interface 型別將協定定義為一組具名的公用函式成員。 實作 interface 的 class 或 struct 必須提供介面的函式成員的實作。 interface 可以繼承自多個基底介面，class 或 struct可實作多個介面。 delegate 型別代表對方法的參考，其中含有特定參數清單與傳回型別。 委派讓您可將方法視為實體，而實體能指派給變數或當作參數來傳遞。 委派類似函式語言提供的函式型別。 它們也類似其他程式設計語言中的函式指標，但與函式指標的不同之處是，委派是物件導向且為型別安全。 class、struct、interface 和 delegate 類型全都支援泛型，因此它們可以使用其他類型來參數化。 enum 型別是具名型別中一個特別的型別。 每個 enum 型別必須是八種整數型別之一。 enum 型別的值組與基礎型別的值組相同。 C# 支持任何型別的一維及多維陣列。 不同於上述型別，陣列型別不需宣告即可使用。 而陣列型別的建構方法，是在型別名稱之後加上方括弧。 例如，int[] 是 int 的單一維度陣列、int[,] 是 int 的雙維陣列，而 int[][] 是 int 的單一維度陣列的單一維度陣列。 可為null的實值型別可不經宣告即可使用，針對每個不可為 Null 的實值型別 T，會有一個對應的可為 Null 實值型別 T?，其中可包含一個額外值 null。 比方說，int? 是可包含任一 32 位元整數或值 null 的型別。 C# 的型別系統是已整合的，任何型別值均可視為一個 object。 C# 中的每個型別都直接或間接衍生自 object 類別型別，而 object 是所有型別的基底類別。 參考型別的值之所以會視為物件，只是將這些值當作 object 型別來檢視。 數值型別的值之所以會視為物件，只是透過執行 boxing 和 unboxing 作業。 在下列範例中，int 值會轉換成 object，並再次轉換回 int。 12345678910using System;class BoxingExample&#123; static void Main() &#123; int i = 123; object o = i; // Boxing int j = (int)o; // Unboxing &#125;&#125;]]></content>
      <categories>
        <category>C# 語法學習</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 語法學習_Lesson 1]]></title>
    <url>%2F2019%2F11%2F14%2FCsharp%2FCsharp_Learning%2FLesson.1%2F</url>
    <content type="text"><![CDATA[C# 語法學習_Lesson 1前言C#是什麼！？C#(C Sharp)是微軟推出的一種基於.NET Framework及物件導向的進階程式語言，IDE開發工具主要是使用Microsoft Visual Studio來進行程式碼撰寫，可於微軟Visual Studio官網自行選擇合適的版本下載安裝。 *本篇以Visual Studio 2019版本進行範例圖示說明 建立第一個專案 點擊「Visual Studio 2019」程式，當IDE完成啟動後，點選「建立新的專案」。 找尋「主控台應用程式(.NET Framework)」，點選後，並按「下一步」 將「專案名稱」命名為「HelloTest」，如果自已有設定程式存放目錄位置的需求，可調整「位置」資訊，確認沒問題，按下「建立」，這樣新專案就建立完成了。 Hello WorldC#原始程式檔的副檔名通常是 .cs。因此在上述建立的「HelloTest」專案所產生的程式檔，點擊「Program.cs」檔案，打開後便是C#主要的程式碼，請在Main()方法加入下列兩段程式碼： 12Console.WriteLine("Hello World!!!");Console.ReadLine(); 整個程式碼區段結果如下： 1234567891011121314151617using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace HelloTest&#123; class Program &#123; static void Main(string[] args) &#123; Console.WriteLine("Hello World!!!"); Console.ReadLine(); &#125; &#125;&#125; 點擊「開始」鍵，執行 會出現執行畫面如下，會看到程式碼經過編譯後，會產生一個名為HelloTest.exe的執行檔，並執行秀出「Hello World!!!」字樣。 程式結構C#最重要的組織結構為程式(programs)、命名空間(namespaces)、型別(types)、成員(members)、組件(Assemblies)。 C#程式(programs)包含一個或多個原始程式檔案，在程式(program)中要宣告型別(type)，其中需要包含成員(members)且可以依據命名空間(namespace)來組織分類。 類別(Classes)和介面(Interfaces)是型別(types)的實例。 欄位(Fields)、方法(Methods)、屬性(properties)及事件(events)為成員(members)的實例。 當C#程式(programs)被編譯後(compiled)，會被封裝成組件(assemblies)，組件的副檔名一般會以.exe 或 .dll存在，分別在於是以「應用程式」或「程式庫」來實作而區分。 我們以下列程式碼來說明，此範例會在名為 Acme.Collections的命名空間(namespace)中, 宣告一個名為「Stack」的類別： 1234567891011121314151617181920212223242526272829303132333435using System;namespace Acme.Collections&#123; public class Stack &#123; class Entry &#123; public Entry next; public object data; public Entry(Entry next, object data) &#123; this.next = next; this.data = data; &#125; &#125; Entry top; public void Push(object data) &#123; top = new Entry(top, data); &#125; public object Pop() &#123; if (top == null) &#123; throw new InvalidOperationException(); &#125; object result = top.data; top = top.next; return result; &#125; &#125;&#125; 此類別(class)的完整名稱為 Acme.Collections.Stack，該類別包含了幾個成員(members) 一個名為 Entry 的巢狀類別(class)。 一個名為 top 的欄位(field)。 兩個名為 Push 和 Pop 的方法(method)。 Entry 類別則包含了三個成員(members) 一個名為 next 的欄位(field)。 一個名為 data 的欄位(field)。 一個則是 Entry 類別本身的建構子(constructor)]]></content>
      <categories>
        <category>C# 語法學習</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET MVC 5 WebDeploy 設定記錄]]></title>
    <url>%2F2019%2F08%2F26%2FWeb_deploy%2FIIS%2FMVCWebDeployToIIS%2F</url>
    <content type="text"><![CDATA[ASP.NET MVC 5 WebDeploy 設定記錄 前言最近開始利用 .NET MVC 5開發專案(遲遲到現在才開始進入MVC的世界)，進度也到了部署的階段，經由GOOGLE大神牽引，看到了Web Deploy，在Visual Studio上很方便的部署機制，眼睛為之一亮，就是這個了，原來這個部署方式已經歷行很久了，我這井底之蛙，以前的部署還一直在單純的使用copy &amp; paste(汗顏啊)，也藉這個主題來練習markdown，把設定的過程記錄起來，供日後參考 部署設定需要動到的地方，分成了兩個部份 部署IIS Server端 Visual Studio 開發端 * IIS Server 設定Step1. 安裝 WebPlatformInstaller (選擇os 對應的位元版本 x64 or 32位元) Step2. 新增Server端本機部署用的帳號(避免直接使用),並將該user加入 Administators 群組 Step3. 開啟IIS管理員(建立站台)，在這裡僅以Default Web Site站台為例，滑鼠右鍵，點擊從組件庫安裝應用程式 Step4. 點選產品tag，並於右方搜尋欄內查詢web deploy，安裝三項應用程式，安裝完後，關閉IIS管理員程式，並重新開啟IIS管理員 Web Deploy 3.6 Web Deploy 3.6 without bundled SQL support(latest) Web Deploy 3.6 for Hosting Servers Step5. 點選左側Default Web Site站台後，右方會出現IIS管理員權限圖示，點擊後，將剛剛建立部署用的system user加入到清單內 Step6. 點選左側Default Web Site站台，滑鼠右鍵，會看見清單多了部署項目，展開後點選啟用Web Deploy發行，並指定好部署用的帳號及sql連結資訊後，按下設定鍵， 至此 IIS Server端的Web Deploy安裝及設定，告一段落了，接下來回到 Visual Studio 開發端的部署設定 * Visual Studio 開發端 設定setp1. 開啟Visual Studio專案後，點選建置(B)功能列，展開後，點選發行 xxxxxxx(xxxxxx為專案名) step2. 點選IIS、FTP 等，並點擊建立設定檔按扭 step3. 填寫部署的資訊後，點擊驗證連線，確認是否可以正常連線成功，正常即可按下儲存按扭 設定完成後，後續即可依這個設定檔進行一鍵部署的動作了，以上是這次設定部署的記錄。 Troubleshooting IIS Server 安裝了 Web Deploy套件，但 IIS管理員站台 一直沒有出現部署選項 123將自行下載安裝或webplatform installer或server 服務安裝的 web deploy套件移除後，再重新透過webplatform installer重新 安裝三個web deploy套件，再重新啟動IIS管理員，應該就會出現了]]></content>
      <categories>
        <category>主機服務建置及設定</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>Web Deploy</tag>
        <tag>IIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown 語法學習]]></title>
    <url>%2F2019%2F08%2F26%2FMarkDown%2FMarkdown-learning%2F</url>
    <content type="text"><![CDATA[前言記錄一些常用的語法，不定期更新，供日後查詢。 閱讀全文首頁在呈現文章時，能決定顯示那些文字段後插入&lt;!-- more --&gt;，在首頁post的文章會出現閱讀全文按鈕，而不呈現整篇文章 ，此部份效果僅在首頁才會呈現 語法123# 前言 記錄一些常用的語法，不定期更新，供日後查詢。 &lt;!-- more --&gt; 標題Atx型式，在行首插入1到6個#，各對應到標題1至6階，此處不呈現效果，效果同html h1~h6一樣 語法123456# h1 ## h2 ### h3#### h4##### h5###### h6 插入網址連結連結連結文字以[方括號]標記起始，方括號內填入顯示字樣，並在方括號後接著括號，於括號內填入欲連結的網址，如果還要加上連結的title文字，僅需要在網址後面新增一個空格再利用雙引號將title文字包起來即可 語法1[Markdown文件](https://markdown.tw &quot;教學說明&quot;) 效果Markdown文件 行分隔線可以在一行中以三個或以上的 星號* 底線_ 減號-來建立分隔線且行內不可有其它字樣或符號出現 語法123***_________----------------------- 效果 插入圖片Markdown使用一種和連結很相似的語法來標記圖片，目前不支援指定img圖片的寬高，如果需要指定的話，可以直接使用html &lt;img&gt;標籤。 語法12![顯示字樣](/image_path/img.jpg)![顯示字樣](/image_path/img.jpg &quot;title&quot;) 清單支援有序清單及無序清單兩種類型。 無序清單使用星號、加號或是減號做為清單標記 語法123* 清單一+ 清單二- 清單三 效果 清單一 清單二 清單三 有序清單則使用數字接著一個英文句點： 語法1231. 清單一2. 清單二3. 清單三 效果 清單一 清單二 清單三]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
